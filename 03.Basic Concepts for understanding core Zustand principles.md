# Basic Concepts: Understanding Core Zustand Principles

This document covers the fundamental concepts and principles of Zustand that you need to understand before working with more advanced features.

## 1. What is a Store?

A **store** is a single source of truth that holds your application's state and the functions to update that state. It's similar to Redux, but simpler and more lightweight.

### Store Characteristics

- Holds application state
- Contains functions to modify state (actions)
- Can be accessed from any component
- Reactive - components re-render when accessed state changes
- Minimal boilerplate compared to Redux

### Simple Store Anatomy

```javascript
import { create } from "zustand";

const useStore = create((set) => ({
	// STATE
	count: 0,
	name: "John",

	// ACTIONS (methods to update state)
	increment: () => set((state) => ({ count: state.count + 1 })),
	setName: (name) => set({ name }),
}));
```

## 2. Creating Stores - Detailed Breakdown

### The `create()` Function

`create()` is the main function that creates a Zustand store.

```javascript
const useStore = create((set, get) => ({
	// Store definition
}));
```

### Understanding `set` and `get`

#### `set()` - Update State

Used to update the store's state. Can take an object or a function.

**Object form (preferred for simple updates):**

```javascript
const useStore = create((set) => ({
	count: 0,
	increment: () => set({ count: 1 }), // Direct object
}));
```

**Function form (for accessing previous state):**

```javascript
const useStore = create((set) => ({
	count: 0,
	increment: () => set((state) => ({ count: state.count + 1 })),
}));
```

#### `get()` - Read Current State

Access the current state within actions without subscribing to changes.

```javascript
const useStore = create((set, get) => ({
	count: 0,
	text: "Hello",

	// Use get() to access current state
	logStatus: () => {
		const state = get();
		console.log(`Count: ${state.count}, Text: ${state.text}`);
	},

	// Combine get() with set()
	incrementIfPositive: () => {
		const { count } = get();
		if (count > 0) {
			set({ count: count + 1 });
		}
	},
}));
```

## 3. State Selectors

A **selector** is a function that extracts specific properties from the store state. Selectors are crucial for performance optimization.

### Why Use Selectors?

```javascript
// ❌ BAD: Entire state selection
const store = useStore();
const count = store.count; // But store has many properties
const name = store.name;
// Component re-renders when ANY state changes

// ✅ GOOD: Specific selector
const count = useStore((state) => state.count);
// Component re-renders only when 'count' changes
```

### Selector Patterns

#### Single Property Selector

```javascript
const count = useStore((state) => state.count);
const name = useStore((state) => state.name);
```

#### Multiple Properties (Object)

```javascript
const { count, increment } = useStore((state) => ({
	count: state.count,
	increment: state.increment,
}));
```

#### Using Shallow Equality for Objects

```javascript
import { shallow } from "zustand/react/shallow";

// Without shallow, object selector recreates on every render
const result = useStore((state) => ({
	x: state.x,
	y: state.y,
})); // Re-renders even if x and y haven't changed

// With shallow, only re-renders if x or y actually changed
const result = useStore(
	(state) => ({
		x: state.x,
		y: state.y,
	}),
	shallow,
);
```

## 4. Updating State

### Basic State Updates

```javascript
const useCounterStore = create((set) => ({
	count: 0,

	// Simple update
	setCount: (count) => set({ count }),

	// Update based on current state
	increment: () => set((state) => ({ count: state.count + 1 })),

	// Multiple properties
	updateMultiple: (count, name) => set({ count, name }),
}));
```

### Updating Nested State

```javascript
const useStore = create((set) => ({
	user: {
		name: "John",
		age: 30,
		address: {
			city: "New York",
			zip: "10001",
		},
	},

	// ✅ Correct: Merge new state (spread operator)
	updateUserName: (name) =>
		set((state) => ({
			user: { ...state.user, name },
		})),

	// For deeply nested, use Immer middleware (discussed later)
}));
```

### Batch Updates

```javascript
const useStore = create((set) => ({
	firstName: "",
	lastName: "",
	email: "",

	// Update multiple values at once
	setUser: (firstName, lastName, email) =>
		set({
			firstName,
			lastName,
			email,
		}),
}));
```

## 5. Reading State in Components

### Method 1: Selector Hook (Recommended)

```javascript
import useCounterStore from "../stores/counterStore";

function Counter() {
	const count = useCounterStore((state) => state.count);
	const increment = useCounterStore((state) => state.increment);

	return (
		<div>
			<p>Count: {count}</p>
			<button onClick={increment}>Increment</button>
		</div>
	);
}
```

### Method 2: Destructuring in Hook

```javascript
function Counter() {
	const { count, increment } = useCounterStore((state) => ({
		count: state.count,
		increment: state.increment,
	}));

	return (
		<div>
			<p>Count: {count}</p>
			<button onClick={increment}>Increment</button>
		</div>
	);
}
```

### Method 3: Entire Store (Use with Caution)

```javascript
function Counter() {
	const store = useCounterStore();
	// Re-renders on ANY state change
	// Use only when necessary

	return <p>Count: {store.count}</p>;
}
```

## 6. Accessing State Outside Components

Sometimes you need to access store state outside React components.

### Using `getState()` (Manual Subscription)

```javascript
const useStore = create((set, get) => ({
	count: 0,
	increment: () => set((state) => ({ count: state.count + 1 })),
}));

// Access state outside component
const state = useStore.getState();
console.log(state.count);

// Call actions
useStore.getState().increment();
```

### Subscribe to State Changes

```javascript
const useStore = create((set) => ({
	count: 0,
	increment: () => set((state) => ({ count: state.count + 1 })),
}));

// Subscribe to store changes
const unsubscribe = useStore.subscribe(
	(state) => state.count,
	(count) => {
		console.log(`Count changed: ${count}`);
	},
);

// Unsubscribe when done
unsubscribe();
```

## 7. Derived State

**Derived state** is computed state - values calculated from other state values.

### Computing Values in Components

```javascript
function CartSummary() {
	const items = useCartStore((state) => state.items);

	// Derived state in component
	const total = items.reduce((sum, item) => sum + item.price, 0);
	const itemCount = items.length;

	return (
		<div>
			<p>Items: {itemCount}</p>
			<p>Total: ${total}</p>
		</div>
	);
}
```

### Computing in Store (Memoized)

```javascript
import { create } from "zustand";

const useCartStore = create((set, get) => ({
	items: [],

	addItem: (item) =>
		set((state) => ({
			items: [...state.items, item],
		})),

	// Derived state as method
	getTotal: () => {
		const { items } = get();
		return items.reduce((sum, item) => sum + item.price, 0);
	},

	getItemCount: () => get().items.length,
}));

// Use in component
function Cart() {
	const items = useCartStore((state) => state.items);
	const getTotal = useCartStore((state) => state.getTotal);

	return <p>Total: ${getTotal()}</p>;
}
```

## 8. Resetting State

### Reset to Initial Values

```javascript
const useStore = create((set) => {
	const initialState = {
		count: 0,
		name: "John",
	};

	return {
		...initialState,

		reset: () => set(initialState),

		increment: () => set((state) => ({ count: state.count + 1 })),
	};
});
```

### Partial Reset

```javascript
const useStore = create((set) => ({
	count: 0,
	name: "John",
	age: 30,

	resetCount: () => set({ count: 0 }),

	resetName: () => set({ name: "John" }),
}));
```

## 9. Practical Examples

### Example 1: Todo Store

```javascript
// src/stores/todoStore.js
import { create } from "zustand";

const useTodoStore = create((set, get) => ({
	todos: [],

	// Add todo
	addTodo: (text) =>
		set((state) => ({
			todos: [...state.todos, { id: Date.now(), text, completed: false }],
		})),

	// Toggle todo
	toggleTodo: (id) =>
		set((state) => ({
			todos: state.todos.map((todo) =>
				todo.id === id ? { ...todo, completed: !todo.completed } : todo,
			),
		})),

	// Delete todo
	deleteTodo: (id) =>
		set((state) => ({
			todos: state.todos.filter((todo) => todo.id !== id),
		})),

	// Get stats
	getStats: () => {
		const { todos } = get();
		return {
			total: todos.length,
			completed: todos.filter((t) => t.completed).length,
			pending: todos.filter((t) => !t.completed).length,
		};
	},
}));

export default useTodoStore;
```

### Example 2: User Authentication Store

```javascript
// src/stores/authStore.js
import { create } from "zustand";

const useAuthStore = create((set, get) => ({
	user: null,
	isLoading: false,
	error: null,

	// Login
	login: async (email, password) => {
		set({ isLoading: true, error: null });
		try {
			const response = await fetch("/api/login", {
				method: "POST",
				body: JSON.stringify({ email, password }),
			});
			const user = await response.json();
			set({ user, isLoading: false });
		} catch (error) {
			set({ error: error.message, isLoading: false });
		}
	},

	// Logout
	logout: () => set({ user: null, error: null }),

	// Check if logged in
	isLoggedIn: () => get().user !== null,
}));

export default useAuthStore;
```

## 10. Common Patterns

### Pattern 1: Store with Actions

```javascript
const useStore = create((set) => ({
	// State
	count: 0,

	// Actions
	actions: {
		increment: () => set((state) => ({ count: state.count + 1 })),
		decrement: () => set((state) => ({ count: state.count - 1 })),
	},
}));

// Usage
const actions = useStore((state) => state.actions);
actions.increment();
```

### Pattern 2: Immutable Updates with Spread

```javascript
const useStore = create((set) => ({
	user: { name: "John", email: "john@example.com" },

	updateUser: (updates) =>
		set((state) => ({
			user: { ...state.user, ...updates },
		})),
}));
```

### Pattern 3: Combining Multiple Stores

```javascript
// In a component
function Dashboard() {
	const authUser = useAuthStore((state) => state.user);
	const cartItems = useCartStore((state) => state.items);

	return (
		<div>
			<p>User: {authUser.name}</p>
			<p>Cart Items: {cartItems.length}</p>
		</div>
	);
}
```

## Key Takeaways

1. ✅ Use **selectors** to avoid unnecessary re-renders
2. ✅ Keep stores **focused** on a single domain
3. ✅ Use **`get()`** to access state in actions
4. ✅ Use **spread operator** for immutable updates
5. ✅ Access state **outside components** with `getState()`
6. ✅ **Subscribe** to specific state changes when needed
7. ✅ Compute **derived state** as needed
8. ✅ Keep state **structure simple** initially

## Practice Exercises

1. Create a counter store and use it in a component
2. Create a todo store with add, delete, and toggle actions
3. Use selectors to optimize component re-renders
4. Access store state outside a component
5. Create a store with derived state (e.g., calculate totals)

---

**Next:** Continue to 04.Advanced Patterns for more sophisticated store designs and optimization techniques.

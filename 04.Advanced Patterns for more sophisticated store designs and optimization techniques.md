# Advanced Patterns: Sophisticated Store Designs and Optimization Techniques

This document covers advanced patterns, optimization strategies, and best practices for building scalable Zustand stores.

## 1. Store Composition and Modularization

### Splitting Large Stores

Instead of one massive store, break it into focused, domain-specific stores.

```javascript
// ❌ BAD: Mega store with everything
const useStore = create((set) => ({
	// User data
	user: null,
	setUser: () => {},

	// Cart data
	cartItems: [],
	addToCart: () => {},

	// Orders data
	orders: [],
	addOrder: () => {},

	// UI state
	isModalOpen: false,
	toggleModal: () => {},

	// More and more...
}));
```

```javascript
// ✅ GOOD: Separate focused stores
// src/stores/authStore.js
const useAuthStore = create((set) => ({
	user: null,
	setUser: (user) => set({ user }),
}));

// src/stores/cartStore.js
const useCartStore = create((set) => ({
	items: [],
	addItem: (item) =>
		set((state) => ({
			items: [...state.items, item],
		})),
}));

// src/stores/uiStore.js
const useUiStore = create((set) => ({
	isModalOpen: false,
	toggleModal: () =>
		set((state) => ({
			isModalOpen: !state.isModalOpen,
		})),
}));
```

### Combining Multiple Stores

```javascript
// src/hooks/useCombinedStore.js
import useAuthStore from "../stores/authStore";
import useCartStore from "../stores/cartStore";

export const useCombinedStore = () => ({
	auth: useAuthStore(),
	cart: useCartStore(),
});

// Usage in component
function Dashboard() {
	const { auth, cart } = useCombinedStore();
	return (
		<div>
			<p>User: {auth.user?.name}</p>
			<p>Cart items: {cart.items.length}</p>
		</div>
	);
}
```

## 2. Middleware Patterns

### Creating Custom Middleware

Middleware allows you to intercept state updates and perform side effects.

```javascript
// src/middleware/loggingMiddleware.js
const loggingMiddleware = (config) => (set, get, api) =>
	config(
		(args) => {
			console.log("Previous state:", get());
			set(args);
			console.log("New state:", get());
		},
		get,
		api,
	);

// Usage
import { create } from "zustand";
import loggingMiddleware from "./middleware/loggingMiddleware";

const useStore = create(
	loggingMiddleware((set) => ({
		count: 0,
		increment: () => set((state) => ({ count: state.count + 1 })),
	})),
);
```

### Combining Multiple Middleware

```javascript
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";

const useStore = create(
	devtools(
		persist(
			(set) => ({
				count: 0,
				increment: () => set((state) => ({ count: state.count + 1 })),
			}),
			{ name: "store-storage" },
		),
		{ name: "MyStore" },
	),
);
```

### Async Actions Middleware

```javascript
const asyncMiddleware = (config) => (set, get, api) =>
	config(
		async (args) => {
			if (typeof args === "function") {
				const result = await args(get(), set);
				set(result);
			} else {
				set(args);
			}
		},
		get,
		api,
	);

// Usage
const useAsyncStore = create(
	asyncMiddleware((set) => ({
		data: null,
		loading: false,

		fetchData: async () => {
			set({ loading: true });
			const response = await fetch("/api/data");
			const data = await response.json();
			return { data, loading: false };
		},
	})),
);
```

## 3. Performance Optimization

### Using Shallow Comparison

```javascript
import { shallow } from "zustand/react/shallow";

const useStore = create((set) => ({
	x: 0,
	y: 0,
	z: 0,
	increment: () => set((state) => ({ x: state.x + 1 })),
}));

function Component() {
	// Without shallow: re-renders even if { x, y } object hasn't changed
	const { x, y } = useStore((state) => ({ x: state.x, y: state.y }));

	// With shallow: only re-renders if x or y values actually change
	const position = useStore((state) => ({ x: state.x, y: state.y }), shallow);

	return (
		<div>
			Position: {position.x}, {position.y}
		</div>
	);
}
```

### Auto-Memoization with `useShallow`

```javascript
import { useShallow } from "zustand/react/useShallow";

function Component() {
	// Automatically memoizes selector result
	const { x, y } = useStore(
		useShallow((state) => ({ x: state.x, y: state.y })),
	);

	return (
		<div>
			Position: {x}, {y}
		</div>
	);
}
```

### Selector Optimization

```javascript
// ❌ BAD: Creates new object on every render
const obj = useStore((state) => ({
	name: state.user.name,
	email: state.user.email,
}));

// ✅ GOOD: Use memoization outside if needed
import { useMemo } from "react";

const userInfo = useStore((state) => state.user);
const memoizedObj = useMemo(
	() => ({
		name: userInfo.name,
		email: userInfo.email,
	}),
	[userInfo.name, userInfo.email],
);
```

### Subscription-based Updates

For high-frequency updates, use subscriptions instead of hooks:

```javascript
// src/utils/storeListener.js
export const subscribeToStore = (store, selector, callback) => {
	const unsubscribe = store.subscribe(
		(state) => selector(state),
		(value) => callback(value),
	);
	return unsubscribe;
};

// Usage outside component
const unsubscribe = subscribeToStore(
	useCounterStore,
	(state) => state.count,
	(count) => console.log(`Count changed to: ${count}`),
);

// Cleanup
unsubscribe();
```

## 4. Immer Integration

Immer simplifies immutable updates for deeply nested state.

```bash
npm install immer
```

```javascript
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";

const useStore = create(
	immer((set) => ({
		user: {
			profile: {
				name: "John",
				settings: {
					theme: "dark",
					notifications: true,
				},
			},
		},

		// Update nested state easily
		updateTheme: (theme) =>
			set((state) => {
				state.user.profile.settings.theme = theme;
			}),

		// Modify arrays
		todos: [{ id: 1, text: "Learn Zustand", completed: false }],

		toggleTodo: (id) =>
			set((state) => {
				const todo = state.todos.find((t) => t.id === id);
				if (todo) {
					todo.completed = !todo.completed;
				}
			}),

		// Add items
		addTodo: (text) =>
			set((state) => {
				state.todos.push({ id: Date.now(), text, completed: false });
			}),
	})),
);
```

## 5. DevTools Integration

### Browser DevTools Setup

```javascript
import { create } from "zustand";
import { devtools } from "zustand/middleware";

const useStore = create(
	devtools(
		(set) => ({
			count: 0,
			increment: () => set((state) => ({ count: state.count + 1 })),
			decrement: () => set((state) => ({ count: state.count - 1 })),
		}),
		{ name: "CounterStore" }, // Store name for DevTools
	),
);
```

### Redux DevTools Browser Extension

1. Install Redux DevTools extension from browser store
2. Use `devtools` middleware (as shown above)
3. Open DevTools → Redux tab
4. View all state changes, time-travel debug, and dispatch actions

## 6. Persist State to Storage

### localStorage Persistence

```javascript
import { create } from "zustand";
import { persist } from "zustand/middleware";

const useAuthStore = create(
	persist(
		(set) => ({
			user: null,
			token: null,

			login: (user, token) => set({ user, token }),
			logout: () => set({ user: null, token: null }),
		}),
		{
			name: "auth-storage", // Key in localStorage
			storage: localStorage, // Can also use sessionStorage
			partialize: (state) => ({
				token: state.token, // Only persist token
			}),
		},
	),
);
```

### Custom Storage

```javascript
const useStore = create(
	persist(
		(set) => ({
			data: null,
			setData: (data) => set({ data }),
		}),
		{
			name: "custom-store",
			storage: {
				getItem: (name) => {
					// Custom retrieval logic
					return JSON.parse(localStorage.getItem(name));
				},
				setItem: (name, value) => {
					// Custom storage logic
					localStorage.setItem(name, JSON.stringify(value));
				},
				removeItem: (name) => {
					localStorage.removeItem(name);
				},
			},
		},
	),
);
```

## 7. Advanced State Patterns

### State Snapshots

Create immutable snapshots of state for comparison:

```javascript
const useStore = create((set, get) => ({
	data: { count: 0 },

	snapshotState: () => {
		return JSON.parse(JSON.stringify(get()));
	},

	updateData: (count) => set({ data: { count } }),
}));

// Usage
const snapshot1 = useStore.getState().snapshotState();
useStore.getState().updateData(5);
const snapshot2 = useStore.getState().snapshotState();
```

### State Migrations

Handle breaking changes when schema evolves:

```javascript
import { create } from "zustand";
import { persist } from "zustand/middleware";

const useStore = create(
	persist(
		(set) => ({
			user: null,
			setUser: (user) => set({ user }),
		}),
		{
			name: "user-store",
			migrate: (persistedState, version) => {
				if (version === 0) {
					// Migration from v0 to v1
					return {
						...persistedState,
						user: {
							...persistedState.user,
							updatedAt: new Date().toISOString(),
						},
					};
				}
				return persistedState;
			},
			version: 1,
		},
	),
);
```

### Undo/Redo Pattern

```javascript
const useStore = create((set, get) => ({
	// Core state
	value: 0,

	// History tracking
	history: [0],
	historyIndex: 0,

	// Update with history
	setValue: (newValue) =>
		set((state) => {
			const newHistory = state.history.slice(0, state.historyIndex + 1);
			newHistory.push(newValue);

			return {
				value: newValue,
				history: newHistory,
				historyIndex: newHistory.length - 1,
			};
		}),

	// Undo
	undo: () =>
		set((state) => {
			const newIndex = Math.max(0, state.historyIndex - 1);
			return {
				value: state.history[newIndex],
				historyIndex: newIndex,
			};
		}),

	// Redo
	redo: () =>
		set((state) => {
			const newIndex = Math.min(
				state.history.length - 1,
				state.historyIndex + 1,
			);
			return {
				value: state.history[newIndex],
				historyIndex: newIndex,
			};
		}),
}));
```

## 8. Type-Safe Patterns (TypeScript)

### Strong Typing with Interfaces

```typescript
interface User {
	id: string;
	name: string;
	email: string;
}

interface AuthState {
	user: User | null;
	loading: boolean;
	error: string | null;
	login: (email: string, password: string) => Promise<void>;
	logout: () => void;
}

const useAuthStore = create<AuthState>((set) => ({
	user: null,
	loading: false,
	error: null,

	login: async (email: string, password: string) => {
		set({ loading: true, error: null });
		try {
			// API call
			const user = await fetchUser(email, password);
			set({ user, loading: false });
		} catch (error) {
			set({ error: (error as Error).message, loading: false });
		}
	},

	logout: () => set({ user: null }),
}));
```

### Generic Store Factory

```typescript
interface StoreState<T> {
	data: T | null;
	loading: boolean;
	error: string | null;
	setData: (data: T) => void;
	setLoading: (loading: boolean) => void;
	setError: (error: string | null) => void;
}

const createDataStore = <T>(initialData: T | null = null) =>
	create<StoreState<T>>((set) => ({
		data: initialData,
		loading: false,
		error: null,
		setData: (data) => set({ data }),
		setLoading: (loading) => set({ loading }),
		setError: (error) => set({ error }),
	}));

// Usage
const useUserStore = createDataStore<User>(null);
const useProductStore = createDataStore<Product>(null);
```

## 9. Testing Zustand Stores

### Unit Testing Stores

```javascript
// src/__tests__/counterStore.test.js
import { renderHook, act } from "@testing-library/react";
import useCounterStore from "../stores/counterStore";

describe("counterStore", () => {
	beforeEach(() => {
		useCounterStore.setState({ count: 0 });
	});

	it("should initialize with count 0", () => {
		const { result } = renderHook(() => useCounterStore());
		expect(result.current.count).toBe(0);
	});

	it("should increment count", () => {
		const { result } = renderHook(() => useCounterStore());

		act(() => {
			result.current.increment();
		});

		expect(result.current.count).toBe(1);
	});

	it("should decrement count", () => {
		useCounterStore.setState({ count: 5 });
		const { result } = renderHook(() => useCounterStore());

		act(() => {
			result.current.decrement();
		});

		expect(result.current.count).toBe(4);
	});
});
```

### Testing with Selectors

```javascript
it("should select specific properties", () => {
	const { result } = renderHook(() => useCounterStore((state) => state.count));

	expect(result.current).toBe(0);
});
```

## 10. Real-World Example: Complete E-Commerce Store

```javascript
// src/stores/ecommerceStore.js
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";

const useEcommerceStore = create(
	devtools(
		persist(
			immer((set, get) => ({
				// State
				products: [],
				cart: [],
				user: null,
				orders: [],
				filters: {
					category: null,
					priceRange: [0, 1000],
					searchTerm: "",
				},

				// Product Actions
				fetchProducts: async () => {
					try {
						const response = await fetch("/api/products");
						const products = await response.json();
						set({ products });
					} catch (error) {
						console.error("Failed to fetch products", error);
					}
				},

				// Cart Actions
				addToCart: (product) =>
					set((state) => {
						const existing = state.cart.find((p) => p.id === product.id);
						if (existing) {
							existing.quantity += 1;
						} else {
							state.cart.push({ ...product, quantity: 1 });
						}
					}),

				removeFromCart: (productId) =>
					set((state) => {
						state.cart = state.cart.filter((p) => p.id !== productId);
					}),

				updateQuantity: (productId, quantity) =>
					set((state) => {
						const item = state.cart.find((p) => p.id === productId);
						if (item) {
							item.quantity = quantity;
						}
					}),

				clearCart: () => set({ cart: [] }),

				// User Actions
				setUser: (user) => set({ user }),

				logout: () => set({ user: null }),

				// Order Actions
				checkout: async () => {
					set({ user: { ...get().user, loading: true } });
					try {
						const response = await fetch("/api/orders", {
							method: "POST",
							body: JSON.stringify({ items: get().cart }),
						});
						const order = await response.json();
						set((state) => {
							state.orders.push(order);
							state.cart = [];
						});
					} catch (error) {
						console.error("Checkout failed", error);
					}
				},

				// Filter Actions
				setFilter: (filterKey, value) =>
					set((state) => {
						state.filters[filterKey] = value;
					}),

				// Selectors
				getCartTotal: () => {
					const { cart } = get();
					return cart.reduce(
						(sum, item) => sum + item.price * item.quantity,
						0,
					);
				},

				getFilteredProducts: () => {
					const { products, filters } = get();
					return products.filter((product) => {
						const matchCategory =
							!filters.category || product.category === filters.category;
						const matchPrice =
							product.price >= filters.priceRange[0] &&
							product.price <= filters.priceRange[1];
						const matchSearch =
							!filters.searchTerm ||
							product.name
								.toLowerCase()
								.includes(filters.searchTerm.toLowerCase());
						return matchCategory && matchPrice && matchSearch;
					});
				},
			})),
			{
				name: "ecommerce-store",
				partialize: (state) => ({
					cart: state.cart,
					user: state.user,
					orders: state.orders,
				}),
			},
		),
		{ name: "EcommerceStore" },
	),
);

export default useEcommerceStore;
```

## Best Practices Summary

1. ✅ **Modularize**: Split large stores into focused domain stores
2. ✅ **Use selectors**: Optimize re-renders with specific selectors
3. ✅ **Leverage middleware**: Use built-in middleware for common tasks
4. ✅ **Test stores**: Write unit tests for store logic
5. ✅ **Type everything**: Use TypeScript for type safety
6. ✅ **Persist strategically**: Only persist necessary state
7. ✅ **Monitor performance**: Use DevTools and profiling
8. ✅ **Handle async properly**: Use middleware for async operations
9. ✅ **Document stores**: Add comments explaining complex logic
10. ✅ **Keep it simple**: Don't over-engineer early on

---

**Next:** Continue to practical projects and real-world applications using Zustand.
